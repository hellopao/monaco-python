{
	"abs()": {
		"prefix": "abs()",
		"body": "abs(${1:num})",
		"description": [
			"Syntax:",
			"abs(num)"
		]
	},
	"any()": {
		"prefix": "any()",
		"body": "any(${1:iterable})",
		"description": [
			"Syntax:",
			"any(iterable)"
		]
	},
	"all()": {
		"prefix": "all()",
		"body": "all(${1:iterable})",
		"description": [
			"Syntax:",
			"all(iterable)"
		]
	},
	"ascii()": {
		"prefix": "ascii()",
		"body": "ascii(${1:object})",
		"description": [
			"Syntax:",
			"ascii(object)"
		]
	},
	"bin()": {
		"prefix": "bin()",
		"body": "bin(${1:num})",
		"description": [
			"Syntax:",
			"bin(num)"
		]
	},
	"bool()": {
		"prefix": "bool()",
		"body": "bool(${1:value})",
		"description": [
			"Syntax:",
			"bool([value])"
		]
	},
	"bytearray()": {
		"prefix": "bytearray()",
		"body": "bytearray(${1:value})",
		"description": [
			"Syntax:",
			"bytearray([source[, encoding[, errors]]])"
		]
	},
	"callable()": {
		"prefix": "callable()",
		"body": "callable(${1:object})",
		"description": [
			"Syntax:",
			"callable(object)"
		]
	},
	"bytes()": {
		"prefix": "bytes()",
		"body": "bytes(${1:value})",
		"description": [
			"Syntax:",
			"bytes([source[, encoding[, errors]]])"
		]
	},
	"chr()": {
		"prefix": "chr()",
		"body": "chr(${1:integer})",
		"description": [
			"Syntax:",
			"chr(integer)"
		]
	},
	"compile()": {
		"prefix": "compile()",
		"body": "compile(${1:source}, ${2:filename}, ${3:mode})",
		"description": [
			"Syntax:",
			"compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)"
		]
	},
	"classmethod()": {
		"prefix": "classmethod()",
		"body": "classmethod(${1:function})",
		"description": [
			"Syntax:",
			"classmethod(function)"
		]
	},
	"complex()": {
		"prefix": "complex()",
		"body": "complex(${1:})",
		"description": [
			"Syntax:",
			"complex([real[, imag]])"
		]
	},
	"delattr()": {
		"prefix": "delattr()",
		"body": "delattr(${1:object}, ${2:name})",
		"description": [
			"Syntax:",
			"delattr(object, name)"
		]
	},
	"dict()": {
		"prefix": "dict()",
		"body": "dict(${1:})",
		"description": [
			"Syntax:",
			"class dict(**kwarg)",
			"class dict(mapping, **kwarg)",
			"class dict(iterable, **kwarg)"
		]
	},
	"dir()": {
		"prefix": "dir()",
		"body": "dir(${1:object})",
		"description": [
			"Syntax:",
			"dir([object])"
		]
	},
	"divmod()": {
		"prefix": "divmod()",
		"body": "divmod(${1:x}, ${2:y})",
		"description": [
			"Syntax:",
			"divmod(x, y)"
		]
	},
	"enumerate()": {
		"prefix": "enumerate()",
		"body": "enumerate(${1:iterable})",
		"description": [
			"Syntax:",
			"enumerate(iterable, start=0)"
		]
	},
	"staticmethod()": {
		"prefix": "staticmethod()",
		"body": "staticmethod(${1:function})",
		"description": [
			"Syntax:",
			"staticmethod(function)"
		]
	},
	"filter()": {
		"prefix": "filter()",
		"body": "filter(${1:function}, ${2:iterable})",
		"description": [
			"Syntax:",
			"filter(function, iterable)"
		]
	},
	"eval()": {
		"prefix": "eval()",
		"body": "eval(${1:expression})",
		"description": [
			"Syntax:",
			"eval(expression, globals=None, locals=None)"
		]
	},
	"float()": {
		"prefix": "float()",
		"body": "float(${1:x})",
		"description": [
			"Syntax:",
			"float([x])"
		]
	},
	"format()": {
		"prefix": "format()",
		"body": "format(${1:})",
		"description": [
			"Syntax:",
			"format(value[, format_spec])",
			"string.format(p0, p1, ..., k0=v0, k1=v1, ...) # String Method"
		]
	},
	"frozenset()": {
		"prefix": "frozenset()",
		"body": "frozenset(${1:})",
		"description": [
			"Syntax:",
			"frozenset([iterable])",
			"set.frozenset([iterable]) # Set Method"
		]
	},
	"getattr()": {
		"prefix": "getattr()",
		"body": "getattr(${1:object}, ${2:name})",
		"description": [
			"Syntax:",
			"getattr(object, name[, default])"
		]
	},
	"globals()": {
		"prefix": "globals()",
		"body": "globals()",
		"description": [
			"Syntax:",
			"globals()"
		]
	},
	"exec()": {
		"prefix": "exec()",
		"body": "exec(${1:object})",
		"description": [
			"Syntax:",
			"exec(object, globals, locals)"
		]
	},
	"hasattr()": {
		"prefix": "hasattr()",
		"body": "hasattr(${1:object}, ${2:name})",
		"description": [
			"Syntax:",
			"hasattr(object, name)"
		]
	},
	"help()": {
		"prefix": "help()",
		"body": "help(${1:object})",
		"description": [
			"Syntax:",
			"help(object)"
		]
	},
	"hex()": {
		"prefix": "hex()",
		"body": "hex(${1:x})",
		"description": [
			"Syntax:",
			"hex(x)"
		]
	},
	"hash()": {
		"prefix": "hash()",
		"body": "hash(${1:object})",
		"description": [
			"Syntax:",
			"hash(object)"
		]
	},
	"input()": {
		"prefix": "input()",
		"body": "input(${1:prompt})",
		"description": [
			"Syntax:",
			"input([prompt])"
		]
	},
	"id()": {
		"prefix": "id()",
		"body": "id(${1:object})",
		"description": [
			"Syntax:",
			"id(object)"
		]
	},
	"isinstance()": {
		"prefix": "isinstance()",
		"body": "isinstance(${1:object}, ${2:classinfo})",
		"description": [
			"Syntax:",
			"isinstance(object, classinfo)"
		]
	},
	"int()": {
		"prefix": "int()",
		"body": "int(${1:x})",
		"description": [
			"Syntax:",
			"int(x=0, base=10)"
		]
	},
	"issubclass()": {
		"prefix": "issubclass()",
		"body": "issubclass(${1:class}, ${2:classinfo})",
		"description": [
			"Syntax:",
			"issubclass(class, classinfo)"
		]
	},
	"iter()": {
		"prefix": "iter()",
		"body": "iter(${1:object})",
		"description": [
			"Syntax:",
			"iter(object, sentinel)"
		]
	},
	"list()": {
		"prefix": "list()",
		"body": "list(${1:iterable})",
		"description": [
			"Syntax:",
			"list([iterable])"
		]
	},
	"locals()": {
		"prefix": "locals()",
		"body": "locals()",
		"description": [
			"Syntax:",
			"locals()"
		]
	},
	"len()": {
		"prefix": "len()",
		"body": "len(${1:s})",
		"description": [
			"Syntax:",
			"len(s)"
		]
	},
	"max()": {
		"prefix": "max()",
		"body": "max(${1:iterable})",
		"description": [
			"Syntax:",
			"# to find the largest item in an iterable",
			"max(iterable, *iterables, key, default)",
			"# to find the largest item between two or more objects",
			"max(arg1, arg2, *args, key)"
		]
	},
	"min()": {
		"prefix": "min()",
		"body": "min(${1:iterable})",
		"description": [
			"Syntax:",
			"# to find the smallest item in an iterable",
			"min(iterable, *iterables, key, default)",
			"# to find the smallest item between two or more objects",
			"min(arg1, arg2, *args, key)"
		]
	},
	"map()": {
		"prefix": "map()",
		"body": "map(${1:function}, ${2:iterable})",
		"description": [
			"Syntax:",
			"map(function, iterable, ...)"
		]
	},
	"next()": {
		"prefix": "next()",
		"body": "next(${1:iterator})",
		"description": [
			"Syntax:",
			"next(iterator, default)"
		]
	},
	"memoryview()": {
		"prefix": "memoryview()",
		"body": "memoryview(${1:obj})",
		"description": [
			"Syntax:",
			"memoryview(obj)"
		]
	},
	"object()": {
		"prefix": "object()",
		"body": "object()",
		"description": [
			"Syntax:",
			"o = object()"
		]
	},
	"oct()": {
		"prefix": "oct()",
		"body": "oct(${1:x})",
		"description": [
			"Syntax:",
			"oct(x)"
		]
	},
	"ord()": {
		"prefix": "ord()",
		"body": "ord(${1:ch})",
		"description": [
			"Syntax:",
			"ord(ch)"
		]
	},
	"open()": {
		"prefix": "open()",
		"body": "open(${1:file})",
		"description": [
			"Syntax:",
			"open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)"
		]
	},
	"pow()": {
		"prefix": "pow()",
		"body": "pow(${1:x}, ${2:y})",
		"description": [
			"Syntax:",
			"pow(x, y, z)"
		]
	},
	"print()": {
		"prefix": "print()",
		"body": "print(${1:string})",
		"description": [
			"Syntax:",
			"print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)"
		]
	},
	"property()": {
		"prefix": "property()",
		"body": "property(${1:object})",
		"description": [
			"Syntax:",
			"property(fget=None, fset=None, fdel=None, doc=None)"
		]
	},
	"range()": {
		"prefix": "range()",
		"body": "range(${1:num})",
		"description": [
			"Syntax:",
			"range(stop)",
			"range(start, stop[, step])"
		]
	},
	"repr()": {
		"prefix": "repr()",
		"body": "repr(${1:obj})",
		"description": [
			"Syntax:",
			"repr(obj)"
		]
	},
	"reversed()": {
		"prefix": "reversed()",
		"body": "reversed(${1:seq})",
		"description": [
			"Syntax:",
			"reversed(seq)"
		]
	},
	"round()": {
		"prefix": "round()",
		"body": "round(${1:num})",
		"description": [
			"Syntax:",
			"round(number, ndigits)"
		]
	},
	"set()": {
		"prefix": "set()",
		"body": "set(${1:iterable})",
		"description": [
			"Syntax:",
			"set(iterable)"
		]
	},
	"setattr()": {
		"prefix": "setattr()",
		"body": "setattr(${1:object}, ${2:name}, ${3:value})",
		"description": [
			"Syntax:",
			"setattr(object, name, value)"
		]
	},
	"slice()": {
		"prefix": "slice()",
		"body": "slice(${1:num})",
		"description": [
			"Syntax:",
			"slice(start, stop, step)"
		]
	},
	"sorted()": {
		"prefix": "sorted()",
		"body": "sorted(${1:iterable})",
		"description": [
			"Syntax:",
			"sorted(iterable, key=None, reverse=False)"
		]
	},
	"str()": {
		"prefix": "str()",
		"body": "str(${1:object})",
		"description": [
			"Syntax:",
			"str(object, encoding='utf-8', errors='strict')"
		]
	},
	"sum()": {
		"prefix": "sum()",
		"body": "sum(${1:iterable})",
		"description": [
			"Syntax:",
			"sum(iterable, start)"
		]
	},
	"tuple()": {
		"prefix": "tuple()",
		"body": "tuple(${1:iterable})",
		"description": [
			"Syntax:",
			"tuple(iterable)"
		]
	},
	"type()": {
		"prefix": "type()",
		"body": "type(${1:object})",
		"description": [
			"Syntax:",
			"type(object)",
			"type(name, bases, dict)"
		]
	},
	"vars()": {
		"prefix": "vars(object)",
		"body": "vars(${1:object})",
		"description": [
			"Syntax:",
			"vars(object)"
		]
	},
	"zip()": {
		"prefix": "zip()",
		"body": "zip(${1:iterables})",
		"description": [
			"Syntax:",
			"zip(*iterables)"
		]
	},
	"__import__()": {
		"prefix": "__import__()",
		"body": "__import__(${1:name}, ${2:globals}, ${3:fromlist}, ${4:level})",
		"description": [
			"Syntax:",
			"__import__(name, globals=None, locals=None, fromlist=(), level=0)"
		]
	},
	"super()": {
		"prefix": "super()",
		"body": "super().__init__(${1:object})",
		"description": [
			"Syntax:",
			"super(object)"
		]
	},
	"clear()": {
		"prefix": "clear()",
		"body": "clear()",
		"description": [
			"Syntax:",
			"dict.clear() # Dictionary Method",
			"list.clear() # List Method",
			"set.clear() # Set Method"
		]
	},
	"copy()": {
		"prefix": "copy()",
		"body": "copy()",
		"description": [
			"Syntax:",
			"dict.copy() # Dictionary Method",
			"list.copy() # List Method",
			"set.copy() # Set Method"
		]
	},
	"fromkeys()": {
		"prefix": "fromkeys()",
		"body": "fromkeys(${1:sequence})",
		"description": [
			"Syntax:",
			"dict.fromkeys(sequence[, value]) # Dictionary Method"
		]
	},
	"get()": {
		"prefix": "get()",
		"body": "get(${1:key})",
		"description": [
			"Syntax:",
			"dict.get(key[, value]) # Dictionary Method"
		]
	},
	"items()": {
		"prefix": "items()",
		"body": "items()",
		"description": [
			"Syntax:",
			"dict.items() # Dictionary Method"
		]
	},
	"keys()": {
		"prefix": "keys()",
		"body": "keys()",
		"description": [
			"Syntax:",
			"dict.keys() # Dictionary Method"
		]
	},
	"popitem()": {
		"prefix": "popitem()",
		"body": "popitem()",
		"description": [
			"Syntax:",
			"dict.popitem() # Dictionary Method"
		]
	},
	"setdefault()": {
		"prefix": "setdefault()",
		"body": "setdefault(${1:key})",
		"description": [
			"Syntax:",
			"dict.setdefault(key[, default_value]) # Dictionary Method"
		]
	},
	"pop()": {
		"prefix": "pop()",
		"body": "pop(${1:})",
		"description": [
			"Syntax:",
			"dict.pop(key[, default]) # Dictionary Method",
			"list.pop(index) # List Method",
			"set.pop() # Set Method"
		]
	},
	"values()": {
		"prefix": "values()",
		"body": "values()",
		"description": [
			"Syntax:",
			"dict.values() # Dictionary Method"
		]
	},
	"update()": {
		"prefix": "update()",
		"body": "update(${1:})",
		"description": [
			"Syntax:",
			"dict.update([other]) # Dictionary Method",
			"set.update(iterable) # Set Method"
		]
	},
	"append()": {
		"prefix": "append()",
		"body": "append(${1:item})",
		"description": [
			"Syntax:",
			"list.append(item) # List Method"
		]
	},
	"extend()": {
		"prefix": "extend()",
		"body": "extend(${1:iterable})",
		"description": [
			"Syntax:",
			"list.extend(iterable) # List Method"
		]
	},
	"insert()": {
		"prefix": "insert()",
		"body": "insert(${1:i}, ${2:element})",
		"description": [
			"Syntax:",
			"list.insert(i, elem) # List Method"
		]
	},
	"remove()": {
		"prefix": "remove()",
		"body": "remove(${1:element})",
		"description": [
			"Syntax:",
			"list.remove(element) # List Method",
			"set.remove(element) # Set Method"
		]
	},
	"index()": {
		"prefix": "index()",
		"body": "index(${1:})",
		"description": [
			"Syntax:",
			"list.index(element, start, end) # List Method",
			"string.index(sub[, start[, end]]) # String Method",
			"tuple.index(element, start, end) # Tuple Method"
		]
	},
	"count()": {
		"prefix": "count()",
		"body": "count(${1:})",
		"description": [
			"Syntax:",
			"list.count(element) # List Method",
			"string.count(substring, start=..., end=...) # String Method",
			"tuple.count(element) # Tuple Method"
		]
	},
	"reverse()": {
		"prefix": "reverse()",
		"body": "reverse()",
		"description": [
			"Syntax:",
			"list.reverse(num) # List Method"
		]
	},
	"sort()": {
		"prefix": "sort()",
		"body": "sort(${1:})",
		"description": [
			"Syntax:",
			"list.sort(key=..., reverse=...) # List Method"
		]
	},
	"add()": {
		"prefix": "add()",
		"body": "add(${1:elem})",
		"description": [
			"Syntax:",
			"set.add(elem) # Set Method"
		]
	},
	"difference()": {
		"prefix": "difference()",
		"body": "difference(${1:set})",
		"description": [
			"Syntax:",
			"set.difference(set1) # Set Method"
		]
	},
	"difference_update()": {
		"prefix": "difference_update()",
		"body": "difference_update(${1:set})",
		"description": [
			"Syntax:",
			"set.difference_update(set1) # Set Method"
		]
	},
	"discard()": {
		"prefix": "discard()",
		"body": "discard(${1:x})",
		"description": [
			"Syntax:",
			"set.discard(x) # Set Method"
		]
	},
	"intersection()": {
		"prefix": "intersection()",
		"body": "intersection(${1:other_sets})",
		"description": [
			"Syntax:",
			"set.intersection(*other_sets) # Set Method"
		]
	},
	"intersection_update()": {
		"prefix": "intersection_update()",
		"body": "intersection_update(${1:other_sets})",
		"description": [
			"Syntax:",
			"set.intersection_update(*other_sets) # Set Method"
		]
	},
	"isdisjoint()": {
		"prefix": "isdisjoint()",
		"body": "isdisjoint(${1:set})",
		"description": [
			"Syntax:",
			"set.isdisjoint(set1) # Set Method"
		]
	},
	"issubset()": {
		"prefix": "issubset()",
		"body": "issubset(${1:set})",
		"description": [
			"Syntax:",
			"set.issubset(set1) # Set Method"
		]
	},
	"issuperset()": {
		"prefix": "issuperset()",
		"body": "issuperset(${1:set})",
		"description": [
			"Syntax:",
			"set.issuperset(set1) # Set Method"
		]
	},
	"symmetric_difference()": {
		"prefix": "symmetric_difference()",
		"body": "symmetric_difference(${1:set})",
		"description": [
			"Syntax:",
			"set.symmetric_difference(set1) # Set Method"
		]
	},
	"symmetric_difference_update()": {
		"prefix": "symmetric_differnece_update()",
		"body": "symmetric_difference_update(${1:set})",
		"description": [
			"Syntax:",
			"set.symmetric_differnece_update(set1) # Set Method"
		]
	},
	"union()": {
		"prefix": "union()",
		"body": "union(${1:other_sets})",
		"description": [
			"Syntax:",
			"set.union(*other_sets)"
		]
	},
	"capitalize()": {
		"prefix": "capitalize()",
		"body": "capitalize()",
		"description": [
			"Syntax:",
			"string.capitalize() # String Method"
		]
	},
	"center()": {
		"prefix": "center()",
		"body": "center(${1:width})",
		"description": [
			"Syntax:",
			"string.center(width[, fillchar]) # String Method"
		]
	},
	"casefold()": {
		"prefix": "casefold()",
		"body": "casefold()",
		"description": [
			"Syntax:",
			"string.casefold() # String Method"
		]
	},
	"endswith()": {
		"prefix": "endswith()",
		"body": "endswith(${1:suffix})",
		"description": [
			"Syntax:",
			"string.endswith(suffix[, start[, end]])"
		]
	},
	"expandtabs()": {
		"prefix": "expandtabs()",
		"body": "expandtabs(${1:tabsize})",
		"description": [
			"Syntax:",
			"string.expandtabs(tabsize) # String Method"
		]
	},
	"encode()": {
		"prefix": "encode()",
		"body": "encode(${1:})",
		"description": [
			"Syntax:",
			"string.encode(encoding='UTF-8', errors='strict') # String Method"
		]
	},
	"find()": {
		"prefix": "find()",
		"body": "find(${1:substring})",
		"description": [
			"Syntax:",
			"string.find(sub[, start[, end]]) # String Method"
		]
	},
	"isalnum()": {
		"prefix": "isalmun()",
		"body": "isalnum()",
		"description": [
			"Syntax:",
			"string.isalnum() # String Method"
		]
	},
	"isalpha()": {
		"prefix": "isalpha()",
		"body": "isalpha()",
		"description": [
			"Syntax:",
			"string.isalpha() # String Method"
		]
	},
	"isdecimal()": {
		"prefix": "isdecimal()",
		"body": "isdecimal()",
		"description": [
			"Syntax:",
			"string.isdecimal() # String Method"
		]
	},
	"isdigit()": {
		"prefix": "isdigit()",
		"body": "isdigit()",
		"description": [
			"Syntax:",
			"string.isdigit() # String Method"
		]
	},
	"isidentifier()": {
		"prefix": "isidentifier()",
		"body": "isidentifier()",
		"description": [
			"Syntax:",
			"string.isidentifier() # String Method"
		]
	},
	"islower()": {
		"prefix": "islower()",
		"body": "islower()",
		"description": [
			"Syntax:",
			"string.islower() # String Method"
		]
	},
	"isnumeric()": {
		"prefix": "isnumeric()",
		"body": "isnumeric()",
		"description": [
			"Syntax:",
			"string.isnumeric() # String Method"
		]
	},
	"isprintable()": {
		"prefix": "isprintable()",
		"body": "isprintable()",
		"description": [
			"Syntax:",
			"string.isprintable() # String Method"
		]
	},
	"isspace()": {
		"prefix": "isspace()",
		"body": "isspace()",
		"description": [
			"Syntax:",
			"string.isspace() # String Method"
		]
	},
	"istitle()": {
		"prefix": "istitle()",
		"body": "istitle()",
		"description": [
			"Syntax:",
			"string.istitle() # String Method"
		]
	},
	"isupper()": {
		"prefix": "isupper()",
		"body": "isupper()",
		"description": [
			"Syntax:",
			"string.isupper() # String Method"
		]
	},
	"join()": {
		"prefix": "join()",
		"body": "join(${1:iterable})",
		"description": [
			"Syntax:",
			"string.join(iterable) # String Method"
		]
	},
	"ljust()": {
		"prefix": "ljust()",
		"body": "ljust(${1:width})",
		"description": [
			"Syntax:",
			"string.ljust(width[, fillchar]) # String Method"
		]
	},
	"rjust()": {
		"prefix": "rjust()",
		"body": "rjust(${1:width})",
		"description": [
			"Syntax:",
			"string.rjust(width[, fillchar]) # String Method"
		]
	},
	"lower()": {
		"prefix": "lower()",
		"body": "lower()",
		"description": [
			"Syntax:",
			"string.lower() # String Method"
		]
	},
	"upper()": {
		"prefix": "upper()",
		"body": "upper()",
		"description": [
			"Syntax:",
			"string.upper() # String Method"
		]
	},
	"swapcase()": {
		"prefix": "swapcase()",
		"body": "swapcase()",
		"description": [
			"Syntax:",
			"string.swapcase() # String Method"
		]
	},
	"lstrip()": {
		"prefix": "lstrip()",
		"body": "lstrip(${1:})",
		"description": [
			"Syntax:",
			"string.lstrip([chars]) # String Method"
		]
	},
	"rstrip()": {
		"prefix": "rstrip()",
		"body": "rstrip(${1:})",
		"description": [
			"Syntax:",
			"string.rstrip([chars]) # String Method"
		]
	},
	"strip()": {
		"prefix": "strip()",
		"body": "strip(${1:})",
		"description": [
			"Syntax:",
			"string.strip([chars]) # String Method"
		]
	},
	"partition()": {
		"prefix": "partition()",
		"body": "partition(${1:separator})",
		"description": [
			"Syntax:",
			"string.partition(separator) # String Method"
		]
	},
	"maketrans()": {
		"prefix": "maketrans()",
		"body": "maketrans(${1:})",
		"description": [
			"Syntax:",
			"string.maketrans(x[, y[, z]]) # String Method"
		]
	},
	"rpartition()": {
		"prefix": "rpartition()",
		"body": "rpartition(${1:separator})",
		"description": [
			"Syntax:",
			"string.rpartition(separator) # String Method"
		]
	},
	"translate()": {
		"prefix": "translate()",
		"body": "translate(${1:table})",
		"description": [
			"Syntax:",
			"string.translate(table) # String Method"
		]
	},
	"replace()": {
		"prefix": "replace()",
		"body": "replace(${1:old}, ${2:new})",
		"description": [
			"Syntax:",
			"string.replace(old, new [, count]) # String Method"
		]
	},
	"rfind()": {
		"prefix": "rfind()",
		"body": "rfind(${1:sub})",
		"description": [
			"Syntax:",
			"string.rfind(sub[, start[, end]]) # String Method"
		]
	},
	"rindex()": {
		"prefix": "rindex()",
		"body": "rindex(${1:sub})",
		"description": [
			"Syntax:",
			"string.rindex(sub[, start[, end]]) # String Method"
		]
	},
	"split()": {
		"prefix": "split()",
		"body": "split(${1:})",
		"description": [
			"Syntax:",
			"string.split([separator [, maxsplit]]) # String Method"
		]
	},
	"rsplit()": {
		"prefix": "rsplit()",
		"body": "rsplit(${1:})",
		"description": [
			"Syntax:",
			"string.rsplit([separator [, maxsplit]]) # String Method"
		]
	},
	"splitlines()": {
		"prefix": "splitlines()",
		"body": "splitlines(${1:})",
		"description": [
			"Syntax:",
			"string.splitlines([keepends]) # String Method"
		]
	},
	"startswith()": {
		"prefix": "startswith()",
		"body": "startswith(${1:prefix})",
		"description": [
			"Syntax:",
			"string.startswith(prefix[, start[, end]]) # String Method"
		]
	},
	"title()": {
		"prefix": "title()",
		"body": "title()",
		"description": [
			"Syntax:",
			"string.title() # String Method"
		]
	},
	"zfill()": {
		"prefix": "zfill()",
		"body": "zfill(${1:width})",
		"description": [
			"Syntax:",
			"string.zfill(width) # String Method"
		]
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ${1:expression}:",
			"\t${2:pass}"
		],
		"description": "Code snippet for an if statement"
	},
	"if/else": {
		"prefix": "if/else",
		"body": [
			"if ${1:condition}:",
			"\t${2:pass}",
			"else:",
			"\t${3:pass}"
		],
		"description": "Code snippet for an if statement with else"
	},
	"elif": {
		"prefix": "elif",
		"body": [
			"elif ${1:expression}:",
			"\t${2:pass}"
		],
		"description": "Code snippet for an elif"
	},
	"else": {
		"prefix": "else",
		"body": [
			"else:",
			"\t${1:pass}"
		],
		"description": "Code snippet for an else"
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ${1:expression}:",
			"\t${2:pass}"
		],
		"description": "Code snippet for a while loop"
	},
	"while/else": {
		"prefix": "while/else",
		"body": [
			"while ${1:expression}:",
			"\t${2:pass}",
			"else:",
			"\t${3:pass}"
		],
		"description": "Code snippet for a while loop with else"
	},
	"for": {
		"prefix": "for",
		"body": [
			"for ${1:target_list} in ${2:expression_list}:",
			"\t${3:pass}"
		],
		"description": "Code snippet for a for loop"
	},
	"for/else": {
		"prefix": "for/else",
		"body": [
			"for ${1:target_list} in ${2:expression_list}:",
			"\t${3:pass}",
			"else:",
			"\t${4:pass}"
		],
		"description": "Code snippet for a for loop with else"
	},
	"try/except": {
		"prefix": "try/except",
		"body": [
			"try:",
			"\t${1:pass}",
			"except ${2:expression} as ${3:identifier}:",
			"\t${4:pass}"
		],
		"description": "Code snippet for a try/except statement"
	},
	"try/finally": {
		"prefix": "try/finally",
		"body": [
			"try:",
			"\t${1:pass}",
			"finally:",
			"\t${2:pass}"
		],
		"description": "Code snippet for a try/finally statement"
	},
	"try/except/else": {
		"prefix": "try/except/else",
		"body": [
			"try:",
			"\t${1:pass}",
			"except ${2:expression} as ${3:identifier}:",
			"\t${4:pass}",
			"else:",
			"\t${5:pass}"
		],
		"description": "Code snippet for a try/except/else statement"
	},
	"try/except/finally": {
		"prefix": "try/except/finally",
		"body": [
			"try:",
			"\t${1:pass}",
			"except ${2:expression} as ${3:identifier}:",
			"\t${4:pass}",
			"finally:",
			"\t${5:pass}"
		],
		"description": "Code snippet for a try/except/finally statement"
	},
	"try/except/else/finally": {
		"prefix": "try/except/else/finally",
		"body": [
			"try:",
			"\t${1:pass}",
			"except ${2:expression} as ${3:identifier}:",
			"\t${4:pass}",
			"else:",
			"\t${5:pass}",
			"finally:",
			"\t${6:pass}"
		],
		"description": "Code snippet for a try/except/else/finally statement"
	},
	"with": {
		"prefix": "with",
		"body": [
			"with ${1:expression} as ${2:target}:",
			"\t${3:pass}"
		],
		"description": "Code snippet for a with statement"
	},
	"def": {
		"prefix": "def",
		"body": [
			"def ${1:funcname}(${2:parameter_list}):",
			"\t${3:pass}"
		],
		"description": "Code snippet for a function definition"
	},
	"def(class method)": {
		"prefix": "def(class method)",
		"body": [
			"def ${1:funcname}(self, ${2:parameter_list}):",
			"\t${3:pass}"
		],
		"description": "Code snippet for a class method"
	},
	"def(static class method)": {
		"prefix": "def(static class method)",
		"body": [
			"@staticmethod",
			"def ${1:funcname}(${2:parameter_list}):",
			"\t${3:pass}"
		],
		"description": "Code snippet for a static class method"
	},
	"def(abstract class method)": {
		"prefix": "def(abstract class method)",
		"body": [
			"def ${1:funcname}(self, ${2:parameter_list}):",
			"\traise NotImplementedError"
		],
		"description": "Code snippet for an abstract class method"
	},
	"class": {
		"prefix": "class",
		"body": [
			"class ${1:classname}(${2:object}):",
			"\t${3:pass}"
		],
		"description": "Code snippet for a class definition"
	},
	"lambda": {
		"prefix": "lambda",
		"body": [
			"lambda ${1:parameter_list}: ${2:expression}"
		],
		"description": "Code snippet for a lambda statement"
	},
	"if(main)": {
		"prefix": "__main__",
		"body": [
			"if __name__ == \"__main__\":",
			"    ${1:pass}"
		],
		"description": "Code snippet for a `if __name__ == \"__main__\": ...` block"
	},
	"async/def": {
		"prefix": "async/def",
		"body": [
			"async def ${1:funcname}(${2:parameter_list}):",
			"\t${3:pass}"
		],
		"description": "Code snippet for an async statement"
	},
	"async/for": {
		"prefix": "async/for",
		"body": [
			"async for ${1:target} in ${2:iter}:",
			"\t${3:block}"
		],
		"description": "Code snippet for an async for statement"
	},
	"async/for/else": {
		"prefix": "async/for/else",
		"body": [
			"async for ${1:target} in ${2:iter}:",
			"\t${3:block}",
			"else:",
			"\t${4:block}"
		],
		"description": "Code snippet for an async for statement with else"
	},
	"async/with": {
		"prefix": "async/with",
		"body": [
			"async with ${1:expr} as ${2:var}:",
			"\t${3:block}"
		],
		"description": "Code snippet for an async with statement"
	},
	"ipdb": {
		"prefix": "ipdb",
		"body": "import ipdb; ipdb.set_trace()",
		"description": "Code snippet for ipdb debug"
	},
	"pdb": {
		"prefix": "pdb",
		"body": "import pdb; pdb.set_trace()",
		"description": "Code snippet for pdb debug"
	},
	"pudb": {
		"prefix": "pudb",
		"body": "import pudb; pudb.set_trace()",
		"description": "Code snippet for pudb debug"
	},
	"add/new/cell": {
		"prefix": "add/new/cell",
		"body": "# %%",
		"description": "Code snippet to add a new cell"
	},
	"from future import ...": {
		"prefix": "fenc",
		"body": [
			"# -*- coding: utf-8 -*-",
			"from __future__ import absolute_import, division, print_function, unicode_literals"
		],
		"description": "Import future statement definitions for python2.x scripts using utf-8 as encoding."
	},
	"from future import ... v1": {
		"prefix": "fenco",
		"body": [
			"# coding: utf-8",
			"from __future__ import absolute_import, division, print_function, unicode_literals"
		],
		"description": "Import future statement definitions for python3.x scripts using utf-8 as encoding."
	},
	"import": {
		"prefix": "im",
		"body": "import ${1:package/module}$0",
		"description": "Import a package or module"
	},
	"from ... import ...": {
		"prefix": "fim",
		"body": "from ${1:package/module} import ${2:names}$0",
		"description": "Import statement that allows individual objects from the module to be imported directly into the caller’s symbol table."
	},
	"New class": {
		"prefix": "class",
		"body": "class ${1:ClassName}(${2:object}):\n\t\"\"\"${3:docstring for $1.}\"\"\"\n\tdef __init__(self, ${4:arg}):\n\t\t${5:super($1, self).__init__()}\n\t\tself.arg = arg\n\t\t$0",
		"description": "Code snippet for a class definition."
	},
	"New method": {
		"prefix": "defs",
		"body": "def ${1:mname}(self, ${2:arg}):\n\t${3:pass}$0",
		"description": "Code snippet for a class method definition."
	},
	"New function": {
		"prefix": "def",
		"body": "def ${1:fname}(${2:arg}):\n\t${3:pass}$0",
		"description": "Code snippet for function definition."
	},
	"New async function": {
		"prefix": "adef",
		"body": "async def ${1:fname}(${2:arg}):\n\t${3:pass}$0",
		"description": "Code snippet for async function definition."
	},
	"New property": {
		"prefix": "property",
		"body": "@property\ndef ${1:foo}(self):\n    \"\"\"${2:The $1 property.}\"\"\"\n    ${3:return self._$1}\n@${4:$1}.setter\ndef ${5:$1}(self, value):\n    ${6:self._$1} = value",
		"description": "New property: get and set via decorator"
	},
	"New froperty": {
		"prefix": "property",
		"body": "def ${1:foo}():\n    doc = \"${2:The $1 property.}\"\n    def fget(self):\n        ${3:return self._$1}\n    def fset(self, value):\n        ${4:self._$1 = value}\n    def fdel(self):\n        ${5:del self._$1}\n    return locals()\n$1 = property(**$1())$0",
		"description": ""
	},
	"try:except:": {
		"prefix": "try",
		"body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}$0",
		"description": "Code Snippet for a try and except blocks."
	},
	"try:except:else:finally": {
		"prefix": "tryef",
		"body": "try:\n\t${1:pass}\nexcept${2: ${3:Exception} as ${4:e}}:\n\t${5:raise}\nelse:\n\t${6:pass}\nfinally:\n\t${7:pass}$0",
		"description": "Code Snippet for a try/except/finally with else statement."
	},
	"try:except:else": {
		"prefix": "trye",
		"body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${5:pass}$0",
		"description": "Code Snippet for a try/except with else statement."
	},
	"try:except:finally": {
		"prefix": "tryf",
		"body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nfinally:\n\t${5:pass}$0",
		"description": "Code Snippet for a try/except/finally."
	},
	"self": {
		"prefix": ".",
		"body": "self.$0",
		"description": "Shortend snippet to reference the self property in an object."
	},
	"__magic__": {
		"prefix": "__",
		"body": "__${1:init}__$0",
		"description": "Code snippet to create magic methods."
	},
	"List comprehension": {
		"prefix": "lc",
		"body": "[${1:value} for ${2:value} in ${3:iterable}]$0",
		"description": "List comprehension for creating a list based on existing lists."
	},
	"List comprehension if else": {
		"prefix": "lcie",
		"body": "[${1:value} if ${2:condition} else ${3:condition} for ${4:value} in ${5:iterable}]$0",
		"description": "List comprehension for creating a list based on existing lists, with conditional if-else statement."
	},
	"List comprehension if filter": {
		"prefix": "lci",
		"body": "[${1:value} for ${2:value} in ${3:iterable} if ${4:condition}$0]",
		"description": "List comprehension for creating a list based on existing lists, with conditional if statement."
	},
	"Dictionary comprehension": {
		"prefix": "dc",
		"body": "{${1:key}: ${2:value} for ${3:key}, ${4:value} in ${5:iterable}}$0",
		"description": "Handy and faster way to create dictories based on existing dictionaries."
	},
	"Dictionary comprehension if filter": {
		"prefix": "dci",
		"body": "{${1:key}: ${2:value} for ${3:key}, ${4:value} in ${5:iterable} if ${6:condition}}$0",
		"description": "Handy and faster way to create dictories based on existing dictionaries, with conditional if statement."
	},
	"Set comprehension": {
		"prefix": "sc",
		"body": "{${1:value} for ${2:value} in ${3:iterable}}$0",
		"description": "Create a set based on existing iterables."
	},
	"Set Comprehension if filter": {
		"prefix": "sci",
		"body": "{${1:value} for ${2:value} in ${3:iterable} if ${4:condition}}$0",
		"description": "Create a set based on existing iterables, with condition if statement."
	},
	"Generator comprehension": {
		"prefix": "gc",
		"body": "(${1:key} for ${2:value} in ${3:iterable})$0",
		"description": "Create a generator based on existing iterables."
	},
	"Generator comprehension if filter": {
		"prefix": "gci",
		"body": "(${1:key} for ${2:value} in ${3:iterable} if ${4:condition})$0",
		"description": "Create a generator based on existing iterables, with condition if statement."
	}
}